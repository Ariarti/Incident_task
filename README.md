# Incident task
***
## Задача
У нас есть набор "инцидентов", N штук. Каждый инцидент имеет id с последовательными значениями от 0 до N-1, два категориальных признака с какими-то целыми значениями от 0 до M-1, и признак времени с каким-то (нецелым) значением от 0 до 1. Задача заключается в следующем: надо написать на Python функцию, которая получает на вход выходной фал, dT и файл с инцидентами, и вычисляет для каждого из N инцидентов количество инцидентов из того же файла, которые удовлетворяют следующим условиям:
1. Предшествуют данному инциденту по времени, при этом разница по времени не превосходит dT;

2. Имеют значения feature1 и feature2, совпадающие с соответствующими значениями данного инцидента.

## Пример
| id | feature1 | feature2 | time |
| ---|:--------:| --------:| --------: |
| 0  | 1        | 0        |0.206520219143|
| 1  | 0        | 0        |0.233725001118|
| 2  | 0        | 1        |0.760992754734|
| 3  | 1        | 1        |0.92776979943|
| 4  | 1        | 0        |0.569711498585|
| 5  | 0        | 1        |0.99224586863|
| 6  | 0        | 0        |0.593264390713|
| 7  | 1        | 0        |0.694181201747|
| 8  | 1        | 1        |0.823812651856|
| 9  | 0        | 1        |0.906011017725|
 
### После вызова программы получаем 
|id |count   |
|---|-----|
| 0  |  0 |
| 1  |  0 |
| 2  | 0  |
| 3  |  1 |
| 4  |  0 |
| 5  |  2 |
| 6  | 0  |
| 7  | 1  |
| 8  | 0  |
| 9  |  1 |
-----
## Реализация
Библиотеки:
```python3
import pandas as pd
import re
```
1. Проверяем с помощью регулярных выражений соответствие вводимых имен входного и выходного файла.
```python3
pattern_w_file = r"\w+[.]{1}csv"
    pattern_r_file = r".+[.]{1}csv"
    if not re.match(pattern_w_file, w_file):
        print("Неверное имя выходного файла!")
    elif not re.match(pattern_r_file, r_file):
        print("Неверный формат входного файла!")
``` 
2. В случае соответсвия имен проверяем корректность вводимого dt и существование файла input.csv и создаём словарь к ключами "[feature1, feature1]" и значениями (id, count)...
```python3
else:  
        try: 
            dt = abs(float(dt))
            with open(r_file) as f:
                d = dict()
                for line in f:
                    line = line.rstrip()
                    s = line.split(",")
                    if len(s) != 4:
                        continue
                    # Записываем в словарь в качестве ключа строку со значениями 
                    # категориальных признаков, а в качестве значений кортеж
                    # со значением id и времени
                    try:
                        if str(s[1:-1]) not in d:
                            d[str(s[1:-1])] = list()
                            d[str(s[1:-1])].append((int(s[0]), float(s[3])))
                        else:
                            d[str(s[1:-1])].append((int(s[0]), float(s[3])))
                    except ValueError:
                        continue
        except FileNotFoundError:
            print("Такого файла не существует!")
        except ValueError:
            print("Неверный фомат dt")
```
3. Если во втором пункте всё сработало то создаём словарь di и проходим по каждому элементу словаря d
```python3
#Пример d:
d = {"[1, 0]" : (1, 0.213),
     "[0, 1]" : (2, 0.433), (3, 0.593),
     "[0, 0]" : (4, 0.364), (5, 0.453),
     }
```
Код
```python3
else:
            # Проходим по всем ключам d, если ключ содержит только одно значение, то
            # данный id не имеет пар.
            di = dict()
            for i in d:
                if len(d[i]) == 1:
                    di[d[i][0][0]] = 0
                else:
                    for k in d[i]:
                        for k1 in d[i]:
                            if 0 < (k[1] - k1[1]) < dt:
                                if k[0] not in di:
                                    di[k[0]] = 1
                                else:
                                    di[k[0]] += 1
                            else:
                                if k[0] not in di:
                                    di[k[0]] = 0
```
4. Далее выполняем создаём DataFrame на базе словаря di и сохраняем его в .csv файл
```python3
            dp = pd.DataFrame(di.items(), index = di.keys(), columns=['id', 'count'])
            dp.sort_index(inplace=True)
            dp.to_csv(w_file, index = False)
            print("The " + w_file + " file was created!")
```
-----
### Ловим:
1. Ошибка имени и формата файла
2. Файл не найден
3. Неверный формат dt, в случае отрицательного dt меняем знак на плюс
4. Если размер строки больше 4 столбцов она не считывается 
5. Если int(id) бросает исключение то данный id пропускаем
-----
### Если M=100, N=1000000, dT=0.3.
MaxTime = 44 seconds
MinTime = 29 seconds
-----
## Генерация таблиц .scv
### Как в примере:
Библиотеки:
```python3
import pandas as pd
```
Код:
```python3
d_test = {
          'id' : [0, 1, 2, 3, 4, 5, 6, 7, 8, 9], 
          'feature1' : [1, 0, 0, 1, 1, 0, 0, 1, 1, 0], 
          'feature2' : [0, 0, 1, 1, 0, 1, 0, 0, 1, 1], 
          'time' : [0.206520219143, 0.233725001118, 0.760992754734, 0.92776979943, 0.569711498585, 0.99224586863, 0.593264390713, 0.694181201747, 0.823812651856, 0.906011017725],
          }
df = pd.DataFrame(d_test)
df.to_csv(r'out.csv', index = False)
```
### Произвольный вариант:
Библиотеки:
```python3
import pandas as pd
import numpy as np
```
Код:
```python3
M = 100
N = 1000000
df = pd.DataFrame({'feature1':np.random.randint(M, size=(N,)), 'feature2':np.random.randint(M, size=(N,)), 'time':np.random.rand(N)})
df.to_csv('incidents.csv', index_label='id')
```
